\documentclass[12pt, a4paper]{article} %minska pointen om du vill ha mindre bokstäver

\usepackage[english]{babel}
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc} 	

\usepackage{amsmath}	% Om du vill använda AMSLaTeX 
\usepackage{amssymb}	% Om du vill använda AMS symboler
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{enumerate}
\usepackage[hidelinks]{hyperref}
\usepackage{tikz} % för tikz-figurer
\usepackage{pgfplots}
\usepackage{csvsimple}
\usepackage{booktabs}

\pgfplotsset{width=0.75\textwidth,compat=1.9}
\usepgfplotslibrary{statistics}

\usepackage[parfill]{parskip}

\usepackage{subcaption} % för flera figurer i en

% Färger för exempelkoden
\usepackage{xcolor}
\definecolor{backcol}{gray}{0.95} % bakgrundfärg
\definecolor{darkpastelgreen}{rgb}{0.01, 0.75, 0.24} % bl.a. kommentarer i koden

\usepackage{listings} % för exempelkod
% Inställningar
\lstset{
	basicstyle=\ttfamily\scriptsize, % monospace, mindre bokstäver
	basewidth  = {.5em,0.5em}, % minskar avståndet mellan bokstäverna (passar fonten)
	numbers=left, numberstyle=\tiny, 
	frame=tb, % streck top och bottom
	breaklines=true, % radbyte vid behov
	backgroundcolor = \color{backcol},
	keywordstyle=\color{blue}, 
	commentstyle=\color{darkpastelgreen},
	captionpos=t,
	framexleftmargin=2mm, % padding
	xleftmargin=2mm, % lägg till marginal för att hållas i linje med texten
	framexrightmargin=2mm,
	xrightmargin=2mm,
	}

\title{Operating systems -- Assignment 2\\Scheduling}

\author{Lennart Jern\\
	CS: ens16ljn\\ \\ \textbf{Teacher}\\ Ahmed Aley}


\begin{document}


\maketitle

\newpage


\section{Introduction}

The Linux kernel provides a number of different scheduling policies that can be used to fine tune the performance of certain applications.
In this report, five different schedulers are evaluated using an artificial, CPU intensive, task.
Three of the tested schedulers are ``normal'', while the last two are ``real-time'' schedulers, meaning that they provide higher priority for their processes than the normal ones do.

The work load consists of a simple program, called \texttt{work}, that sums over a part of Grandi's series\footnote{\url{https://en.wikipedia.org/wiki/Grandi's_series}} ($1-1+1-1+\dots$), using a specified number of threads.
The source code for \texttt{work} can be found in listing \ref{work}.
Since the task is easy to parallelize, only require minimal memory access and no disk access, it should be comparable to CPU intense tasks like compression and matrix calculations.

\section{Implementation (Method?)}

A Bash script (\texttt{timer.sh}, listing \ref{timer}) was used to time the complete task 10 times for each scheduler, for thread counts ranging from 1 to 10.
See code listing \ref{timer} for the code.
Additionally, each thread keeps track of the time taken from the start of its execution until it is finished, and prints this information to \texttt{stdout}, which is forwarded to data files by the bash script.

All this data was then processed by a simple Python program, \texttt{stats}, in order to calculate the median, minimum and maximum run time for each scheduler and thread count; for both the total run times and the individual thread times.
This program can be found in listing \ref{stats}.
In addition to the statistical calculations, \texttt{stats} also produces some figures to describe the data.
The figures and calculations are mostly done using the python libraries Pandas\footnote{\url{http://pandas.pydata.org/}} and Matplotlib\footnote{\url{http://matplotlib.org/}}.

It should be noted here that the processes running with real-time schedulers were run with maximum priority.
Since the other schedulers does not accept a priority setting, other than the nice value, these were left untouched.

All tests were run on my personal computer with the specifications seen in table \ref{spec}.

\begin{table}[h]
	\centering
	\begin{tabular}{ll}
		Component & Specification \\
		\hline
		OS: & Fedora 25 \\
		Kernel: & Linux 4.8.12-300.fc25.x86\_64 \\
		CPU: & Intel Core i5-2500K CPU @ 3.7GHz \\
		RAM: & 7965MiB \\
		GCC: & 6.2.1 \\
		Bash: & 4.3.43 \\
		Python: & 3.5.2 \\
		Pandas: & 0.18.1 \\
		Matplotlib: & 1.5.3
	\end{tabular}
	\caption{Test system specification.}
	\label{spec}
\end{table}



\section{Results}

For the total run time of the process, there does not seem to be much of a difference between the five schedulers.
This is perhaps not too surprising considering that the system was practically idle, except for the work load process, so this process naturally got all resources the system could offer.


% Necessary?
%It is more interesting to compare the range of response times between the schedulers (fig. \ref{range}).
%This reveals a clear difference between the real-time and normal schedulers, where the real-time ones are clearly more predictable for two or more threads.

The raw data collected can be found in appendix \ref{raw}.




\input{threads-median.tex}

\input{threads-min-max.tex}

\input{total-median.tex}

% Necessary?
%\input{range.tex}

\input{box.tex}

\input{density.tex}

\section{Final thoughts and lessons learned}

%\pagebreak
\clearpage
\appendix

\section{Code listings}

\lstinputlisting[language=c, caption=work.c, label=work]{../code/work.c}

\lstinputlisting[language=bash, caption=timer.sh, label=timer]{../code/timer.sh}

\lstinputlisting[language=python, caption=stats.py, label=stats]{../code/stats.py}

\lstinputlisting[caption=Makefile, label=make]{../code/Makefile}

\section{Raw data}\label{raw}

\csvautobooktabular{data/medians.csv}

\csvautobooktabular{data/max.csv}

\csvautobooktabular{data/min.csv}

%\csvautobooktabular{data/data1.csv}
%\csvautobooktabular{data/data2.csv}
%\csvautobooktabular{data/data3.csv}
%\csvautobooktabular{data/data4.csv}
%\csvautobooktabular{data/data5.csv}
%\csvautobooktabular{data/data6.csv}
%\csvautobooktabular{data/data7.csv}
%\csvautobooktabular{data/data8.csv}
%\csvautobooktabular{data/data9.csv}
%\csvautobooktabular{data/data10.csv}

\end{document}
